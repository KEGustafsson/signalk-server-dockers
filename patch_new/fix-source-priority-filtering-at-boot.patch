From e620b33c65eaa2cdd7341c0723f60d6eaeabfbf0 Mon Sep 17 00:00:00 2001
From: Claude <noreply@anthropic.com>
Date: Fri, 26 Dec 2025 09:42:24 +0000
Subject: [PATCH 1/2] Fix source priority filtering at boot time

The source priority filter was not correctly filtering sources during boot time.
The issue was that when no previous value existed for a path, the filtering logic
would fall back to HIGHESTPRECEDENCE for the empty latest source, causing the
timeout check to always pass (since latest.timestamp was 0, representing epoch time).

This meant that ALL sources (both in and not in the priority list) would eventually
be accepted at boot time after their timeout expired, defeating the purpose of the
priority filter.

Changes:
- Modified isPreferredValue() in src/deltaPriority.ts to handle the "no previous value" case
- When latest.sourceRef is empty (no value received yet):
  - Sources in the priority list are accepted immediately as the first value
  - Sources NOT in the priority list are rejected (they can only be used for failover)
- Added comprehensive test case to verify boot-time filtering behavior

This ensures that source priority filtering works correctly from the moment the
server starts, not just after the first value is received.
---
 src/deltaPriority.ts  | 20 +++++++++++
 test/deltaPriority.ts | 82 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 102 insertions(+)

diff --git a/src/deltaPriority.ts b/src/deltaPriority.ts
index b66b738..2ef8b4d 100644
--- a/src/deltaPriority.ts
+++ b/src/deltaPriority.ts
@@ -123,6 +123,26 @@ export const getToPreferredDelta = (
       return true
     }

+    // Special case: no value received yet for this path
+    // Accept any source from the priority list immediately
+    // Reject sources not in the priority list (they can only be used for failover)
+    // This fixes boot-time filtering where all sources were incorrectly allowed through
+    if (latest.sourceRef === '') {
+      const incomingPrecedence = pathPrecedences.get(sourceRef)
+      if (incomingPrecedence) {
+        // Source is in priority list - accept it as the first value
+        if (debug.enabled) {
+          debug(`${path}:${sourceRef}:true:first-value`)
+        }
+        return true
+      }
+      // Source not in priority list - reject at boot (no source to fail over from)
+      if (debug.enabled) {
+        debug(`${path}:${sourceRef}:false:unknown-source-at-boot`)
+      }
+      return false
+    }
+
     const latestPrecedence =
       pathPrecedences.get(latest.sourceRef) || HIGHESTPRECEDENCE
     const incomingPrecedence =
diff --git a/test/deltaPriority.ts b/test/deltaPriority.ts
index 8f0d620..8ab0610 100644
--- a/test/deltaPriority.ts
+++ b/test/deltaPriority.ts
@@ -29,6 +29,88 @@ describe('toPreferredDelta logic', () => {
     assert(delta.updates[0].values === undefined)
   })

+  it('filters non-priority sources at boot time', () => {
+    const sourcePreferences: SourcePrioritiesData = {
+      'navigation.position': [
+        {
+          sourceRef: 'gps.main' as SourceRef,
+          timeout: 5000
+        },
+        {
+          sourceRef: 'gps.backup' as SourceRef,
+          timeout: 5000
+        }
+      ]
+    }
+    const toPreferredDelta = getToPreferredDelta(sourcePreferences, 10000)
+
+    // At boot time, non-priority source 'gps.unknown' should be rejected immediately
+    const unknownSourceDelta = toPreferredDelta(
+      {
+        context: 'self',
+        updates: [
+          {
+            $source: 'gps.unknown' as SourceRef,
+            values: [
+              {
+                path: 'navigation.position',
+                value: { latitude: 60.1, longitude: 24.9 }
+              }
+            ]
+          }
+        ]
+      },
+      new Date(),
+      'self'
+    )
+    // Should filter out the value from unknown source at boot
+    assert.strictEqual(unknownSourceDelta.updates[0].values.length, 0)
+
+    // Priority source 'gps.backup' should be accepted at boot (even though it's not first priority)
+    const backupSourceDelta = toPreferredDelta(
+      {
+        context: 'self',
+        updates: [
+          {
+            $source: 'gps.backup' as SourceRef,
+            values: [
+              {
+                path: 'navigation.position',
+                value: { latitude: 60.2, longitude: 24.8 }
+              }
+            ]
+          }
+        ]
+      },
+      new Date(),
+      'self'
+    )
+    // Should accept the value from priority source
+    assert.strictEqual(backupSourceDelta.updates[0].values.length, 1)
+
+    // Higher priority source 'gps.main' should replace backup
+    const mainSourceDelta = toPreferredDelta(
+      {
+        context: 'self',
+        updates: [
+          {
+            $source: 'gps.main' as SourceRef,
+            values: [
+              {
+                path: 'navigation.position',
+                value: { latitude: 60.3, longitude: 24.7 }
+              }
+            ]
+          }
+        ]
+      },
+      new Date(),
+      'self'
+    )
+    // Should accept the value from higher priority source
+    assert.strictEqual(mainSourceDelta.updates[0].values.length, 1)
+  })
+
   it('works', () => {
     const sourcePreferences: SourcePrioritiesData = {
       'environment.wind.speedApparent': [
--
2.43.0


From 6d935d9a5eb7e4f061db9ade32d9d34727404814 Mon Sep 17 00:00:00 2001
From: Claude <noreply@anthropic.com>
Date: Fri, 26 Dec 2025 09:49:00 +0000
Subject: [PATCH 2/2] Respect source priority timeouts at boot time

Updated the boot-time filtering logic to respect cumulative timeouts for
lower-priority sources, preventing all sources from being accepted immediately.

Previous behavior:
- All sources in the priority list were accepted immediately at boot
- This defeated the purpose of having priority ordering

New behavior:
- Highest priority source (precedence 0): accepted immediately
- Lower priority sources: only accepted after cumulative timeout expires
  - Priority 1: accepted after timeout[0] milliseconds
  - Priority 2: accepted after timeout[0] + timeout[1] milliseconds
  - And so on...
- Unknown sources: accepted after unknownSourceTimeout milliseconds

Example with priority list:
  1. gps.main (timeout: 5000ms)
  2. gps.backup (timeout: 3000ms)
  3. gps.tertiary (timeout: 2000ms)

At boot:
- gps.main: accepted immediately
- gps.backup: accepted only after 5000ms (waiting for gps.main)
- gps.tertiary: accepted only after 8000ms (5000ms + 3000ms)
- unknown sources: accepted after 10000ms (unknownSourceTimeout)

Changes:
- Track filter start time (filterStartTime) in src/deltaPriority.ts
- Calculate cumulative timeout for each source based on higher priority timeouts
- Updated comprehensive test case to verify timeout behavior
---
 src/deltaPriority.ts  |  41 ++++++++++---
 test/deltaPriority.ts | 137 ++++++++++++++++++++++++++++++++++++------
 2 files changed, 148 insertions(+), 30 deletions(-)

diff --git a/src/deltaPriority.ts b/src/deltaPriority.ts
index 2ef8b4d..1d2db09 100644
--- a/src/deltaPriority.ts
+++ b/src/deltaPriority.ts
@@ -67,6 +67,9 @@ export const getToPreferredDelta = (
   }
   const precedences = toPrecedences(sourcePrioritiesData)

+  // Track when filtering started (boot time reference)
+  const filterStartTime = Date.now()
+
   const contextPathTimestamps = new Map<Context, PathLatestTimestamps>()

   const setLatest = (
@@ -123,24 +126,42 @@ export const getToPreferredDelta = (
       return true
     }

-    // Special case: no value received yet for this path
-    // Accept any source from the priority list immediately
-    // Reject sources not in the priority list (they can only be used for failover)
-    // This fixes boot-time filtering where all sources were incorrectly allowed through
+    // Special case: no value received yet for this path (boot time)
+    // Respect priority list and timeouts to avoid accepting all sources immediately
     if (latest.sourceRef === '') {
       const incomingPrecedence = pathPrecedences.get(sourceRef)
       if (incomingPrecedence) {
-        // Source is in priority list - accept it as the first value
+        // Source is in priority list - check if enough time has elapsed
+        // based on cumulative timeouts of higher priority sources
+
+        // Calculate cumulative timeout: sum of timeouts for all higher precedence sources
+        let cumulativeTimeout = 0
+        for (const [, precedenceData] of pathPrecedences) {
+          if (precedenceData.precedence < incomingPrecedence.precedence) {
+            cumulativeTimeout += precedenceData.timeout
+          }
+        }
+
+        const timeSinceBoot = millis - filterStartTime
+        const isPreferred = timeSinceBoot >= cumulativeTimeout
+
         if (debug.enabled) {
-          debug(`${path}:${sourceRef}:true:first-value`)
+          debug(
+            `${path}:${sourceRef}:${isPreferred}:boot-time:precedence=${incomingPrecedence.precedence}:cumulative-timeout=${cumulativeTimeout}:time-since-boot=${timeSinceBoot}`
+          )
         }
-        return true
+        return isPreferred
       }
-      // Source not in priority list - reject at boot (no source to fail over from)
+
+      // Source not in priority list - apply unknown source timeout
+      const timeSinceBoot = millis - filterStartTime
+      const isPreferred = timeSinceBoot >= unknownSourceTimeout
       if (debug.enabled) {
-        debug(`${path}:${sourceRef}:false:unknown-source-at-boot`)
+        debug(
+          `${path}:${sourceRef}:${isPreferred}:boot-time:unknown-source:timeout=${unknownSourceTimeout}:time-since-boot=${timeSinceBoot}`
+        )
       }
-      return false
+      return isPreferred
     }

     const latestPrecedence =
diff --git a/test/deltaPriority.ts b/test/deltaPriority.ts
index 8ab0610..49a2bb1 100644
--- a/test/deltaPriority.ts
+++ b/test/deltaPriority.ts
@@ -29,28 +29,32 @@ describe('toPreferredDelta logic', () => {
     assert(delta.updates[0].values === undefined)
   })

-  it('filters non-priority sources at boot time', () => {
+  it('respects timeouts at boot time', () => {
     const sourcePreferences: SourcePrioritiesData = {
       'navigation.position': [
         {
           sourceRef: 'gps.main' as SourceRef,
-          timeout: 5000
+          timeout: 100 // Wait 100ms before falling back
         },
         {
           sourceRef: 'gps.backup' as SourceRef,
-          timeout: 5000
+          timeout: 100 // Wait another 100ms before falling back
+        },
+        {
+          sourceRef: 'gps.tertiary' as SourceRef,
+          timeout: 100
         }
       ]
     }
-    const toPreferredDelta = getToPreferredDelta(sourcePreferences, 10000)
+    const toPreferredDelta = getToPreferredDelta(sourcePreferences, 400)

-    // At boot time, non-priority source 'gps.unknown' should be rejected immediately
-    const unknownSourceDelta = toPreferredDelta(
+    // Test 1: Highest priority source should be accepted immediately
+    const mainSourceDelta = toPreferredDelta(
       {
         context: 'self',
         updates: [
           {
-            $source: 'gps.unknown' as SourceRef,
+            $source: 'gps.main' as SourceRef,
             values: [
               {
                 path: 'navigation.position',
@@ -63,11 +67,14 @@ describe('toPreferredDelta logic', () => {
       new Date(),
       'self'
     )
-    // Should filter out the value from unknown source at boot
-    assert.strictEqual(unknownSourceDelta.updates[0].values.length, 0)
+    // Highest priority should be accepted immediately
+    assert.strictEqual(mainSourceDelta.updates[0].values.length, 1)
+
+    // Test 2: Create new filter to test timeout behavior from boot
+    const toPreferredDelta2 = getToPreferredDelta(sourcePreferences, 400)

-    // Priority source 'gps.backup' should be accepted at boot (even though it's not first priority)
-    const backupSourceDelta = toPreferredDelta(
+    // Backup source should be rejected initially (before gps.main timeout expires)
+    const backupSourceDeltaEarly = toPreferredDelta2(
       {
         context: 'self',
         updates: [
@@ -82,19 +89,19 @@ describe('toPreferredDelta logic', () => {
           }
         ]
       },
-      new Date(),
+      new Date(Date.now() + 50), // 50ms after boot
       'self'
     )
-    // Should accept the value from priority source
-    assert.strictEqual(backupSourceDelta.updates[0].values.length, 1)
+    // Should be rejected (cumulative timeout for backup = 100ms, but only 50ms elapsed)
+    assert.strictEqual(backupSourceDeltaEarly.updates[0].values.length, 0)

-    // Higher priority source 'gps.main' should replace backup
-    const mainSourceDelta = toPreferredDelta(
+    // After timeout expires, backup source should be accepted
+    const backupSourceDeltaLate = toPreferredDelta2(
       {
         context: 'self',
         updates: [
           {
-            $source: 'gps.main' as SourceRef,
+            $source: 'gps.backup' as SourceRef,
             values: [
               {
                 path: 'navigation.position',
@@ -104,11 +111,101 @@ describe('toPreferredDelta logic', () => {
           }
         ]
       },
-      new Date(),
+      new Date(Date.now() + 150), // 150ms after boot
       'self'
     )
-    // Should accept the value from higher priority source
-    assert.strictEqual(mainSourceDelta.updates[0].values.length, 1)
+    // Should be accepted (cumulative timeout for backup = 100ms, 150ms elapsed)
+    assert.strictEqual(backupSourceDeltaLate.updates[0].values.length, 1)
+
+    // Test 3: Tertiary source needs cumulative timeout of main + backup
+    const toPreferredDelta3 = getToPreferredDelta(sourcePreferences, 400)
+
+    const tertiarySourceEarly = toPreferredDelta3(
+      {
+        context: 'self',
+        updates: [
+          {
+            $source: 'gps.tertiary' as SourceRef,
+            values: [
+              {
+                path: 'navigation.position',
+                value: { latitude: 60.4, longitude: 24.6 }
+              }
+            ]
+          }
+        ]
+      },
+      new Date(Date.now() + 150), // 150ms after boot
+      'self'
+    )
+    // Should be rejected (cumulative timeout = 100 + 100 = 200ms, but only 150ms elapsed)
+    assert.strictEqual(tertiarySourceEarly.updates[0].values.length, 0)
+
+    const tertiarySourceLate = toPreferredDelta3(
+      {
+        context: 'self',
+        updates: [
+          {
+            $source: 'gps.tertiary' as SourceRef,
+            values: [
+              {
+                path: 'navigation.position',
+                value: { latitude: 60.5, longitude: 24.5 }
+              }
+            ]
+          }
+        ]
+      },
+      new Date(Date.now() + 250), // 250ms after boot
+      'self'
+    )
+    // Should be accepted (cumulative timeout = 200ms, 250ms elapsed)
+    assert.strictEqual(tertiarySourceLate.updates[0].values.length, 1)
+
+    // Test 4: Unknown source should respect unknownSourceTimeout
+    const toPreferredDelta4 = getToPreferredDelta(sourcePreferences, 400)
+
+    const unknownSourceEarly = toPreferredDelta4(
+      {
+        context: 'self',
+        updates: [
+          {
+            $source: 'gps.unknown' as SourceRef,
+            values: [
+              {
+                path: 'navigation.position',
+                value: { latitude: 60.6, longitude: 24.4 }
+              }
+            ]
+          }
+        ]
+      },
+      new Date(Date.now() + 300), // 300ms after boot
+      'self'
+    )
+    // Should be rejected (unknownSourceTimeout = 400ms, but only 300ms elapsed)
+    assert.strictEqual(unknownSourceEarly.updates[0].values.length, 0)
+
+    const unknownSourceLate = toPreferredDelta4(
+      {
+        context: 'self',
+        updates: [
+          {
+            $source: 'gps.unknown' as SourceRef,
+            values: [
+              {
+                path: 'navigation.position',
+                value: { latitude: 60.7, longitude: 24.3 }
+              }
+            ]
+          }
+        ]
+      },
+      new Date(Date.now() + 450), // 450ms after boot
+      'self'
+    )
+    // Should be accepted (unknownSourceTimeout = 400ms, 450ms elapsed)
+    assert.strictEqual(unknownSourceLate.updates[0].values.length, 1)
   })

   it('works', () => {
--
2.43.0
