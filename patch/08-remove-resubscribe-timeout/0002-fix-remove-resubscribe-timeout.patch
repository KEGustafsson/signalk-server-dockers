From 5103909f76097dad6f83ae9580e7593d86b6f97c Mon Sep 17 00:00:00 2001
From: Claude <noreply@anthropic.com>
Date: Sun, 22 Feb 2026 11:59:32 +0000
Subject: [PATCH] fix: remove unnecessary 10ms delay in DataBrowser
 resubscription
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The setTimeout(..., 10) between the unsubscribe and subscribe sends
in _executeResubscription was added to "ensure order", but WebSocket
is a full-duplex stream protocol that guarantees in-order delivery on
a single connection. Two consecutive send() calls on the same socket
will always arrive at the server in the order they were sent, with no
artificial delay required.

Remove the timeout so state transitions (RESUBSCRIBING â†’ SUBSCRIBED)
and path tracking happen synchronously, making the code easier to
reason about.

https://claude.ai/code/session_0142hccyF52oZwDAmLrntwTp
---
 .../GranularSubscriptionManager.js            | 67 ++++++++++---------
 1 file changed, 34 insertions(+), 33 deletions(-)

diff --git a/packages/server-admin-ui/src/views/DataBrowser/GranularSubscriptionManager.js b/packages/server-admin-ui/src/views/DataBrowser/GranularSubscriptionManager.js
index 8aa203e..b8f130d 100644
--- a/packages/server-admin-ui/src/views/DataBrowser/GranularSubscriptionManager.js
+++ b/packages/server-admin-ui/src/views/DataBrowser/GranularSubscriptionManager.js
@@ -184,44 +184,45 @@ class GranularSubscriptionManager {
       unsubscribe: [{ path: '*' }]
     })
 
-    // Step 2: Subscribe to new paths (with small delay to ensure order)
-    setTimeout(() => {
-      if (!newPaths || newPaths.size === 0) {
-        this.currentPaths = new Set()
-        this.state = STATE.SUBSCRIBED
-        return
-      }
+    // Step 2: Subscribe to new paths.
+    // WebSocket guarantees in-order delivery on a single connection, so the
+    // subscribe message sent right after the unsubscribe will always be
+    // processed by the server in the correct sequence.
+    if (!newPaths || newPaths.size === 0) {
+      this.currentPaths = new Set()
+      this.state = STATE.SUBSCRIBED
+      return
+    }
 
-      // Extract unique paths (remove source suffix from path$SourceKeys)
-      const uniquePaths = this._extractUniquePaths(newPaths)
+    // Extract unique paths (remove source suffix from path$SourceKeys)
+    const uniquePaths = this._extractUniquePaths(newPaths)
 
-      if (uniquePaths.length === 0) {
-        this.currentPaths = new Set()
-        this.state = STATE.SUBSCRIBED
-        return
-      }
+    if (uniquePaths.length === 0) {
+      this.currentPaths = new Set()
+      this.state = STATE.SUBSCRIBED
+      return
+    }
 
-      const subMsg = {
-        context: '*',
-        announceNewPaths: true, // Continue discovering new paths
-        subscribe: uniquePaths.map((path) => ({ path }))
-      }
+    const subMsg = {
+      context: '*',
+      announceNewPaths: true, // Continue discovering new paths
+      subscribe: uniquePaths.map((path) => ({ path }))
+    }
 
-      this._send(subMsg)
-      this.currentPaths = newPaths
-      this.state = STATE.SUBSCRIBED
+    this._send(subMsg)
+    this.currentPaths = newPaths
+    this.state = STATE.SUBSCRIBED
 
-      // Check if there's a pending request that came in during resubscription
-      if (this.pendingPaths) {
-        const pending = this.pendingPaths
-        this.pendingPaths = null
-        // Debounce the pending request
-        this.debounceTimer = setTimeout(() => {
-          this.debounceTimer = null
-          this._executeResubscription(pending)
-        }, this.DEBOUNCE_MS)
-      }
-    }, 10)
+    // Check if there's a pending request that came in during resubscription
+    if (this.pendingPaths) {
+      const pending = this.pendingPaths
+      this.pendingPaths = null
+      // Debounce the pending request
+      this.debounceTimer = setTimeout(() => {
+        this.debounceTimer = null
+        this._executeResubscription(pending)
+      }, this.DEBOUNCE_MS)
+    }
   }
 
   /**
-- 
2.43.0

