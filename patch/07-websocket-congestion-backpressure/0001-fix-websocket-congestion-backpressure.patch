From e907c1c6ef3dcf28a04e7544f13344ba80d1a6e2 Mon Sep 17 00:00:00 2001
From: Claude <noreply@anthropic.com>
Date: Sun, 22 Feb 2026 10:57:09 +0000
Subject: [PATCH] fix: three WebSocket subscription/congestion bugs
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

1. GranularSubscriptionManager.startDiscovery() did not reset
   currentPaths before re-sending the initial subscribe message.
   On context switch (handleContextChange calls startDiscovery
   without first calling unsubscribeAll), the stale currentPaths
   could satisfy _pathsAreSimilar (â‰¥80% overlap is common when
   switching between vessels with the same Signal K paths), causing
   requestPaths to skip the resubscription and leaving the UI with
   no live data for the new context.

2. Each $backpressure event in actions.js queued a fresh 10-second
   setTimeout for BACKPRESSURE_WARNING_CLEAR without cancelling the
   previous one. Under sustained backpressure the timers accumulated,
   firing redundant state updates long after the warning was already
   cleared. Track the single active timer and cancel it before
   rescheduling.

3. The backpressure enter/accumulate check block was copy-pasted
   verbatim in both the onChange realtime handler and the
   processSubscribe callback in ws.js. Extract it into a
   sendOrAccumulate() helper to eliminate the DRY violation.

https://claude.ai/code/session_0142hccyF52oZwDAmLrntwTp
---
 packages/server-admin-ui/src/actions.js       | 12 +++-
 .../GranularSubscriptionManager.js            |  4 ++
 src/interfaces/ws.js                          | 67 ++++++++-----------
 3 files changed, 41 insertions(+), 42 deletions(-)

diff --git a/packages/server-admin-ui/src/actions.js b/packages/server-admin-ui/src/actions.js
index 586cc78..b82bea7 100644
--- a/packages/server-admin-ui/src/actions.js
+++ b/packages/server-admin-ui/src/actions.js
@@ -156,6 +156,10 @@ export function fetchAllData(dispatch) {
   fetchAccessRequests(dispatch)
 }
 
+// Single timer shared across connections so stale auto-clear dispatches
+// from a previous burst of backpressure events cannot race with newer ones.
+let backpressureClearTimer = null
+
 export function openServerEventsConnection(dispatch, isReconnect) {
   const proto = window.location.protocol === 'https:' ? 'wss' : 'ws'
   const ws = new WebSocket(
@@ -178,8 +182,12 @@ export function openServerEventsConnection(dispatch, isReconnect) {
           timestamp: Date.now()
         }
       })
-      // Auto-clear after 10 seconds
-      setTimeout(() => {
+      // Cancel any pending clear so only the most recent event's timer fires
+      if (backpressureClearTimer) {
+        clearTimeout(backpressureClearTimer)
+      }
+      backpressureClearTimer = setTimeout(() => {
+        backpressureClearTimer = null
         dispatch({ type: 'BACKPRESSURE_WARNING_CLEAR' })
       }, 10000)
     }
diff --git a/packages/server-admin-ui/src/views/DataBrowser/GranularSubscriptionManager.js b/packages/server-admin-ui/src/views/DataBrowser/GranularSubscriptionManager.js
index 8aa203e..05122f8 100644
--- a/packages/server-admin-ui/src/views/DataBrowser/GranularSubscriptionManager.js
+++ b/packages/server-admin-ui/src/views/DataBrowser/GranularSubscriptionManager.js
@@ -54,6 +54,10 @@ class GranularSubscriptionManager {
   startDiscovery() {
     if (!this.webSocket) return
 
+    // Reset path tracking so _pathsAreSimilar does not suppress the first
+    // requestPaths call after a context change or reconnect
+    this.currentPaths = new Set()
+
     log('Starting subscription with announceNewPaths')
 
     // Subscribe with announceNewPaths to discover all paths
diff --git a/src/interfaces/ws.js b/src/interfaces/ws.js
index 47992cc..aafe1e9 100644
--- a/src/interfaces/ws.js
+++ b/src/interfaces/ws.js
@@ -224,26 +224,7 @@ module.exports = function (app) {
           )
           if (!filtered) return
 
-          const bufferSize = spark.request.socket.bufferSize
-
-          if (bufferSize > BACKPRESSURE_ENTER_THRESHOLD) {
-            // Enter/stay in backpressure mode - accumulate latest values only
-            if (!spark.backpressure.active) {
-              spark.backpressure.active = true
-              spark.backpressure.since = Date.now()
-              debug(
-                'Entering backpressure mode for spark %s (buffer: %d)',
-                spark.id,
-                bufferSize
-              )
-            }
-            accumulateLatestValue(spark.backpressure.accumulator, filtered)
-          } else {
-            // Normal mode - send immediately
-            sendMetaData(app, spark, filtered)
-            spark.write(filtered)
-          }
-
+          sendOrAccumulate(app, spark, filtered)
           assertBufferSize(spark)
         }
 
@@ -695,26 +676,7 @@ function processSubscribe(app, unsubscribes, spark, assertBufferSize, msg) {
         )
         if (!filtered) return
 
-        const bufferSize = spark.request.socket.bufferSize
-
-        if (bufferSize > BACKPRESSURE_ENTER_THRESHOLD) {
-          // Enter/stay in backpressure mode - accumulate latest values only
-          if (!spark.backpressure.active) {
-            spark.backpressure.active = true
-            spark.backpressure.since = Date.now()
-            debug(
-              'Entering backpressure mode for spark %s (buffer: %d)',
-              spark.id,
-              bufferSize
-            )
-          }
-          accumulateLatestValue(spark.backpressure.accumulator, filtered)
-        } else {
-          // Normal mode - send immediately
-          sendMetaData(app, spark, filtered)
-          spark.write(filtered)
-        }
-
+        sendOrAccumulate(app, spark, filtered)
         assertBufferSize(spark)
       },
       spark.request.skPrincipal
@@ -872,6 +834,31 @@ function startServerLog(app, spark) {
   }
 }
 
+/**
+ * Send a filtered delta to the client, applying backpressure if the socket
+ * buffer is over threshold.  Extracted to avoid duplicating this logic in
+ * both the realtime onChange handler and the subscription callback.
+ */
+function sendOrAccumulate(app, spark, filtered) {
+  const bufferSize = spark.request.socket.bufferSize
+
+  if (bufferSize > BACKPRESSURE_ENTER_THRESHOLD) {
+    if (!spark.backpressure.active) {
+      spark.backpressure.active = true
+      spark.backpressure.since = Date.now()
+      debug(
+        'Entering backpressure mode for spark %s (buffer: %d)',
+        spark.id,
+        bufferSize
+      )
+    }
+    accumulateLatestValue(spark.backpressure.accumulator, filtered)
+  } else {
+    sendMetaData(app, spark, filtered)
+    spark.write(filtered)
+  }
+}
+
 /**
  * Flush accumulated values as spec-compliant deltas.
  * Uses buildFlushDeltas from LatestValuesAccumulator to build the deltas.
-- 
2.43.0

