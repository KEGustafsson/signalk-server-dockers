From b30ff2d3f6a1f9bd064ef7f215a784e8760ddded Mon Sep 17 00:00:00 2001
From: dirkwa <dirkwahrheit@gmail.com>
Date: Thu, 8 Jan 2026 10:06:38 +1200
Subject: [PATCH 1/2] fix: replace native mdns with @homebridge/ciao to
 eliminate Avahi warnings

Replace the optional native `mdns` package with pure JavaScript
`@homebridge/ciao` library to eliminate Avahi Bonjour compatibility
layer warnings on Linux systems.

The native mdns package uses libavahi-compat-libdnssd-dev which prints
warnings like "The program 'node' uses the Apple Bonjour compatibility
layer of Avahi" and "DNSServiceRegister() is not supported".

Changes:
- Add @homebridge/ciao as dependency
- Remove mdns from optionalDependencies
- Rewrite src/mdns.js to use ciao API
- Update server stop() to handle async interface shutdown
- Add stopping flag to prevent race conditions during shutdown

Benefits:
- No native compilation required
- No Avahi warnings on Linux
- Works on Node.js 18, 20, 22, and 24
- RFC 6762/6763 compliant mDNS implementation
- Cross-platform support (Linux, macOS, Windows)

Tested with full test suite (136 passing) on Node 18, 20, 22, and 24.
---
 package.json |   3 +-
 src/index.ts | 101 ++++++++++++++++-------------
 src/mdns.js  | 176 +++++++++++++++++++++++++++++++++------------------
 src/types.ts |   2 +-
 4 files changed, 173 insertions(+), 109 deletions(-)

diff --git a/package.json b/package.json
index dd00bc904..61e0adfa1 100644
--- a/package.json
+++ b/package.json
@@ -72,6 +72,7 @@
   "dependencies": {
     "@assemblyscript/loader": "^0.28.9",
     "@bytecodealliance/jco": "^1.4.0",
+    "@homebridge/ciao": "^1.3.4",
     "@signalk/course-provider": "^1.0.0",
     "@signalk/n2k-signalk": ">=4.1.0-beta",
     "@signalk/nmea0183-signalk": "^3.0.0",
@@ -95,7 +96,6 @@
     "cookie-parser": "^1.4.3",
     "cors": "^2.5.2",
     "debug": "^4.3.3",
-    "dnssd2": "1.0.0",
     "errorhandler": "^1.3.0",
     "esm-resolve": "^1.0.11",
     "express": "^4.10.4",
@@ -136,7 +136,6 @@
     "@signalk/signalk-to-nmea0183": "^1.0.0",
     "@signalk/udp-nmea-plugin": "^2.0.0",
     "@signalk/vesselpositions": "^1.0.0",
-    "mdns": "^2.5.1",
     "serialport": "^11.0.0",
     "signalk-n2kais-to-nmea0183": "^1.3.1",
     "signalk-to-nmea2000": "^2.16.0"
diff --git a/src/index.ts b/src/index.ts
index 113a411ab..e7f7bde68 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -544,58 +544,71 @@ class Server {
     return this
   }
 
-  async stop(cb?: () => void) {
-    if (!this.app.started) {
-      return this
-    }
-
-    try {
-      _.each(this.app.interfaces, (intf: any) => {
-        if (
-          intf !== null &&
-          typeof intf === 'object' &&
-          typeof intf.stop === 'function'
-        ) {
-          intf.stop()
+  stop(cb?: () => void) {
+    return new Promise((resolve, reject) => {
+      if (!this.app.started) {
+        resolve(this)
+      } else {
+        // Stop all interfaces (some may be async)
+        const stopInterfaces = async () => {
+          const stopPromises = Object.values(this.app.interfaces).map(
+            (intf: any) => {
+              if (
+                intf !== null &&
+                typeof intf === 'object' &&
+                typeof intf.stop === 'function'
+              ) {
+                const result = intf.stop()
+                // Handle both sync and async stops
+                return result instanceof Promise ? result : Promise.resolve()
+              }
+              return Promise.resolve()
+            }
+          )
+          await Promise.all(stopPromises)
         }
-      })
 
-      this.app.intervals.forEach((interval) => {
-        clearInterval(interval)
-      })
-
-      this.app.providers.forEach((providerHolder) => {
-        providerHolder.pipeElements[0].end()
-      })
+        stopInterfaces()
+          .catch((err) => debug('Error stopping interfaces:', err))
+          .then(() => {
+            try {
+              this.app.intervals.forEach((interval) => {
+                clearInterval(interval)
+              })
 
-      debug('Closing server...')
+              this.app.providers.forEach((providerHolder) => {
+                providerHolder.pipeElements[0].end()
+              })
 
-      const that = this
-      return new Promise((resolve, reject) => {
-        this.app.server.close(() => {
-          debug('Server closed')
-          if (that.app.redirectServer) {
-            try {
-              that.app.redirectServer.close(() => {
-                debug('Redirect server closed')
-                delete that.app.redirectServer
-                that.app.started = false
-                cb && cb()
-                resolve(that)
+              debug('Closing server...')
+
+              const that = this
+              this.app.server.close(() => {
+                debug('Server closed')
+                if (that.app.redirectServer) {
+                  try {
+                    that.app.redirectServer.close(() => {
+                      debug('Redirect server closed')
+                      delete that.app.redirectServer
+                      that.app.started = false
+                      cb && cb()
+                      resolve(that)
+                    })
+                  } catch (err) {
+                    reject(err)
+                  }
+                } else {
+                  that.app.started = false
+                  cb && cb()
+                  resolve(that)
+                }
               })
             } catch (err) {
               reject(err)
             }
-          } else {
-            that.app.started = false
-            cb && cb()
-            resolve(that)
-          }
-        })
-      })
-    } catch (err) {
-      throw err
-    }
+          })
+      }
+    })
   }
 }
 
diff --git a/src/mdns.js b/src/mdns.js
index 3d366b681..2d4a6d5d2 100644
--- a/src/mdns.js
+++ b/src/mdns.js
@@ -19,112 +19,164 @@
 const _ = require('lodash')
 import { createDebug } from './debug'
 const debug = createDebug('signalk-server:mdns')
-const dnssd = require('dnssd2')
+const ciao = require('@homebridge/ciao')
 const ports = require('./ports')
 
 module.exports = function mdnsResponder(app) {
   const config = app.config
 
-  let mdns = dnssd
-
-  try {
-    mdns = require('mdns')
-    debug('using  mdns')
-  } catch (ex) {
-    debug(ex)
-    debug('mdns not found, using dnssd2')
-  }
-
   if (typeof config.settings.mdns !== 'undefined' && !config.settings.mdns) {
     debug('Mdns disabled by configuration')
     return
   }
 
+  // Create a single responder instance for all services
+  const responder = ciao.getResponder()
+
+  // Build TXT record, stripping null/empty values
   let txtRecord = {
     txtvers: '1',
     swname: config.name,
     swvers: config.version,
-    // hardcoded out of master/slave, main/aux
     roles: 'master, main',
     self: app.selfId,
     vname: config.vesselName,
     vmmsi: config.vesselMMSI,
     vuuid: config.vesselUUID
   }
-
-  // Strip all the null or empty props in txtRecord
   txtRecord = _.pickBy(txtRecord, _.identity)
 
-  const types = []
-  types.push({
-    type: app.config.settings.ssl ? mdns.tcp('https') : mdns.tcp('http'),
-    port: ports.getExternalPort(app)
+  // Collect services to advertise
+  const services = []
+
+  // Primary HTTP/HTTPS service
+  services.push({
+    name: config.vesselName || config.name || 'SignalK',
+    type: app.config.settings.ssl ? 'signalk-https' : 'signalk-http',
+    port: ports.getExternalPort(app),
+    txt: txtRecord
   })
 
+  // Additional services from interfaces
   for (const key in app.interfaces) {
     if (
       _.isObject(app.interfaces[key]) &&
       _.isObject(app.interfaces[key].mdns)
     ) {
-      const service = app.interfaces[key].mdns
-
-      if (
-        'tcp'.indexOf(service.type) !== -1 &&
-        service.name.charAt(0) === '_'
-      ) {
-        types.push({
-          type: mdns[service.type](service.name),
-          port: service.port
+      const mdnsConfig = app.interfaces[key].mdns
+
+      if (mdnsConfig.type === 'tcp' && mdnsConfig.name.charAt(0) === '_') {
+        // Remove leading underscore - ciao adds it automatically
+        const serviceType = mdnsConfig.name.substring(1)
+        services.push({
+          name: config.vesselName || config.name || 'SignalK',
+          type: serviceType,
+          port: mdnsConfig.port,
+          txt: txtRecord
         })
       } else {
         debug('Not advertising mDNS service for interface: ' + key)
         debug(
-          'mDNS service type should be TCP or HTTP, and the name should start with "_".'
+          'mDNS service type should be TCP, and the name should start with "_".'
         )
       }
     }
   }
 
-  const options = {
-    txtRecord,
-    txt: txtRecord
-  }
-
+  // Configure hostname if different from OS hostname
   const host = app.config.getExternalHostname()
+  const osHostname = require('os').hostname()
+  const serviceOptions = host !== osHostname ? { hostname: host } : {}
+
+  debug('mDNS service options:', serviceOptions)
+
+  const activeServices = []
+  let stopping = false
+  let advertisingPromise = null
+
+  // Start advertising all services
+  const startAdvertising = async () => {
+    for (const svc of services) {
+      // Check if we're stopping before starting each service
+      if (stopping) {
+        debug('Stopping flag set, skipping remaining services')
+        break
+      }
 
-  if (host !== require('os').hostname()) {
-    options.host = host
-  }
+      debug('Starting mDNS ad: _' + svc.type + '._tcp ' + host + ':' + svc.port)
+
+      try {
+        const service = responder.createService({
+          name: svc.name,
+          type: svc.type,
+          port: svc.port,
+          txt: svc.txt,
+          ...serviceOptions
+        })
 
-  debug(options)
-
-  const ads = []
-
-  for (const i in types) {
-    const type = types[i]
-    debug(
-      'Starting mDNS ad: ' +
-        type.type +
-        ' ' +
-        app.config.getExternalHostname() +
-        ':' +
-        type.port
-    )
-    const ad = new mdns.Advertisement(type.type, type.port, options)
-    ad.on('error', (err) => {
-      console.log(type.type.name)
-      console.error(err)
-    })
-    ad.start()
-    ads.push(ad)
+        service.on('name-change', (newName) => {
+          debug(`Service name changed to: ${newName}`)
+        })
+
+        activeServices.push(service)
+
+        // Don't await if we're stopping
+        if (!stopping) {
+          await service.advertise()
+          debug(`Successfully advertising _${svc.type}._tcp`)
+        }
+      } catch (err) {
+        // Ignore errors if we're stopping
+        if (!stopping) {
+          console.error(`Failed to advertise _${svc.type}._tcp:`, err)
+        }
+      }
+    }
   }
 
+  // Start advertising (track the promise so we can wait for it on stop)
+  advertisingPromise = startAdvertising().catch((err) => {
+    if (!stopping) {
+      console.error('mDNS advertising failed:', err)
+    }
+  })
+
   return {
-    stop: function () {
-      ads.forEach(function (ad) {
-        debug('Stopping mDNS advertisement...')
-        ad.stop()
-      })
+    stop: async function () {
+      debug('Stopping mDNS advertisements...')
+
+      // Set stopping flag to prevent new operations
+      stopping = true
+
+      // Wait for advertising to complete or fail (with a timeout)
+      if (advertisingPromise) {
+        try {
+          await Promise.race([
+            advertisingPromise,
+            new Promise((resolve) => setTimeout(resolve, 1000))
+          ])
+        } catch (err) {
+          debug('Error waiting for advertising to complete:', err)
+        }
+      }
+
+      // Stop all services
+      for (const service of activeServices) {
+        try {
+          await service.end()
+        } catch (err) {
+          debug('Error stopping service:', err)
+        }
+      }
+
+      // Shutdown the responder (sends goodbye packets)
+      try {
+        await responder.shutdown()
+      } catch (err) {
+        debug('Error shutting down responder:', err)
+      }
+
+      debug('mDNS advertisements stopped')
     }
   }
 }
diff --git a/src/types.ts b/src/types.ts
index d29977a05..7b65674dc 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -24,7 +24,7 @@ export interface SignalKServer extends ServerAPI {
 
 export class Interface {
   start?: () => void
-  stop?: () => void
+  stop?: () => void | Promise<void>
   mdns?: MdnsAdvertisement
 }
 

From d2daa9e32dd0d98b1efb35c0ca064bf2c44207ec Mon Sep 17 00:00:00 2001
From: dirkwa <dirkwahrheit@gmail.com>
Date: Sun, 11 Jan 2026 03:31:11 +1200
Subject: [PATCH 2/2] fix: use correct port getter for WASM interface mDNS
 advertisement

The WASM interface was using app.config.port which does not exist.
Use getExternalPort() helper which correctly resolves the port from
settings, environment variables, or proxy configuration.
---
 src/interfaces/wasm.ts | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/interfaces/wasm.ts b/src/interfaces/wasm.ts
index 641f34735..3757cbc3f 100644
--- a/src/interfaces/wasm.ts
+++ b/src/interfaces/wasm.ts
@@ -8,6 +8,7 @@
 
 import Debug from 'debug'
 import { initializeWasm, shutdownAllWasmPlugins } from '../wasm'
+import { getExternalPort } from '../ports'
 
 const debug = Debug('signalk:interfaces:wasm')
 
@@ -17,7 +18,7 @@ module.exports = (app: any) => {
   api.mdns = {
     name: '_signalk-wasm',
     type: 'tcp',
-    port: app.config.port
+    port: getExternalPort(app)
   }
 
   api.start = () => {
